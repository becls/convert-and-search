\documentclass[letterpaper,11pt,twoside,final]{article}
\usepackage{sagian}

\begin{document}

\title{Database Searcher and Log File Converter Design}
\author{Alyssa Crawford}
\date{August 6, 2018}
\coverpage

\section*{Introduction}
The database searcher and log file converter is a stand-alone
application built to facilitate easy retrieval of information from
instrument log files and SQLite database files.
In the case of
database files, the application allows the user to perform basic
searches through a GUI, or to enter SQL statements. These searches can
then be saved for future use. The user can easily switch between saved
databases. The application can
also convert textual log files into an easier-to-search database.
It was built specifically with the
needs of tech support in mind; however, other parties may also find it
useful.

This application uses the Swish Concurrency Engine (\url{https://github.com/becls/swish}) to interface with
the databases, run the conversions, and to display the
results. Electron (\url{https://electronjs.org/}) is used create a framework for displaying the pages generated by Swish.  

\section*{Theory of Operation}
\subsection*{Overall Setup}
The application runs on a local web server on port 54321.
It uses the web server provided by Swish in order to
create the web pages. Electron is then used to display these web pages as a native
desktop application. These pages are displayed as a desktop
application for two main reasons:
\begin{enumerate}
  \item Each user needs a separate list of saved searches and
    databases. Though this could have been achieved through user
    accounts, that would decrease usability as the user would have to
    remember their login information, potentially with long gaps between
    uses.
  \item Uploading the entire database file to the server would be detrimental to server performance as many of the databases
    are several thousand megabytes. A desktop application has the
    advantage that the file can remain stored on the user's computer and
    the application only has to store the path to the file.
\end{enumerate}
Electron is also helpful because it provides utilities for packaging
the application into an easy-to-run program. When the program is run, it starts Swish in the
background so that the desired pages are available. When the
application is closed Swish is also closed.

\subsection*{Information Storage and Database Access}
At any given time, the application is connected to two databases: the
user selected database and the Swish log database. The user-selected
database is used by the two types of searches and is only edited if
the user creates a view.

The Swish log file is modified during initial setup in order to facilitate storing
databases and searches. The setup process adds two tables,
one for databases and one for searches. Activities that refer to saved
  searches or databases use these tables. Unlike the user-selected database,
the Swish log file is often edited, such as when the user saves a
search.
q1
\subsection*{Searcher}
The goal behind the different search pages is to provide the user maximum
flexibility while still providing an easy to use interface. The user
can therefore choose one of three search setups: normal search, two
table search, and advanced search.

Normal search allows the user to
search one table at a time. There are several optional search options
in normal search that provide the user more choices. The user can
select a column and enter a search term and search for rows where that
column contains that search term. They can also exclude rows that
contain a specified keyword. If the table contains a column labeled
dateTime or timestamp the user can limit the results to those that
occur within a specific time range. Lastly, the user can choose how
the results are ordered. 
The program parses the values entered by the user into a SQLite
query. As part of this parsing, columns named ``Timestamp'' are
converted into a human readable date-time format rather than the large
integer stored in the Biomek logs and other databases.

Another provided search GUI is designed to help the user join results
from two tables. The user is prompted to choose two tables, and a
column from each table. Using a SQLite join statement, the program
displays all results where the two columns are equal. The data from
the columns used for the join is only displayed once, with the column
name specified by the user.

Lastly, the user has the option to do an advanced search. This option
allows the user to write their own SQLite select statement
directly. Though the most powerful search option, it requires the
user to be familiar with SQLite syntax.

From the results page of any of these searches the user can save the
search. The user can then easily re-run the search, including on a
different database that has the same schema. The user can also edit
the search, export the search, create a view of the search, or delete
the search from the list of saved searches. Creating a view of the
search allows the user to treat the results of the search as a table
and perform further queries on it.

\subsection*{Converter}
The log file converter is designed to convert specific log files into a database. The database format makes it easy to search
multiple log files at the same time, and reduces redundant
information. Some important information about the expected formats:
\begin{itemize}
  \item The converter only converts files in the current
directory. Subdirectories are ignored. This decision was made to
increase converter speed and because these folders usually
do not have subdirectories. 
  \item There are two conversion modes. In only convert files that end
    in a date, the system only converts files which end in some
    combination of digits, periods, spaces and slashes. Other files
    are skipped. In convert all files, all files are converted, which
    can lead to converting files whose contents do not match the
    expected form. In either case, the first part of the filename
    becomes the name of the table in the database.

    For example, if the filename fits the following pattern:
    \textbf{<name>dd-mm-yyyy HH.MM.SS.log},
    \textbf{<name>} will
    become the name of a table in the database. If the filename is
    \textbf{<name>.log}, it will only be converted if the user chooses
    to convert all files. If the file is converted, \textbf{<name>}
    will be the name of the table in the database.
  \item There are two types of tables created, data tables and header
    tables. There is only one header table created. Each file adds one
    entry to the header table that describes the information found at
    the top of the file. Data tables contain the information
    found in the main body of the log file. There are as many data
    tables created as there are unique convertible file names, i.e., one
    table is created for each unique value of \textbf{<name>} as
    described above.
    \item
    Each data table created has four columns, Run number, method, dateTime, and
    desc. Run number is automatically generated and refers to the
    corresponding entry in the Header table. This allows the
    repetitive header information to be hidden, but provides the user
    a way to determine that information. The remaining three columns
    are explained below.
  \item The converter expects the header of a given file to include
    the following line: \textbf{Method = <Method name>}, where
    \textbf{<Method name>} does not contain any newline characters. \textbf{<Method name>} is
    saved as the value of the method for each row generated by that
    file. If the pattern \textbf{Method = <Method name>} does not
    appear in the file header, the value of method will be blank for
    all entries generated by that file.
  \item Excluding the header, the converter expects the contents of
    the file to follow the following format: \textbackslash n\textbf{mm/dd/yyyy HH:MM:SS,<Desc>}, where \textbf{<Desc>} can
    contain anything other than a newline followed by a date. Each
    occurrence of this pattern becomes an entry in the corresponding
    table. The \textbf{mm/dd/yyyy HH:MM:SS} section becomes the dateTime, and
    the \textbf{<Desc>} becomes the desc.
\end{itemize}


\end{document}
